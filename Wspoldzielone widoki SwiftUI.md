# Wspoldzielone widoki SwiftUI

https://youtu.be/UhDdtdeW63k?si=656caDyKr_iEt08m

Budowanie aplikacji SwiftUI jest trochę jak budowanie LEGO. Masz pudełko pełne błyszczących i ekscytujących małych klocków i bardzo łatwo jest zacząć. Dosłownie po prostu klikasz rzeczy razem w ten sposób. Ale po pewnym czasie możesz znaleźć się w środku dość skomplikowanej konstrukcji. Z pewnością wygląda niesamowicie, ale kiedy zajrzysz pod maskę, zdasz sobie sprawę, że wszystko wymknęło się spod kontroli i staje się coraz trudniejsze do przedłużenia, ponieważ wszystko jest połączone i usieciowane. I to jest ten moment, kiedy myślisz sobie, czy nie ma lepszego sposobu, aby to zrobić? Jeśli to ty, to dobrze się znajdujesz. W tej serii nauczę Cię, jak tworzyć aplikacje SwiftUI, które są łatwe do utrzymania i rozszerzenia. Zaczniemy od samego początku i przyjrzymy się, jak możemy zrefaktoryzować istniejącą aplikację SwiftUI i uczynić ją łatwiejszą do zrozumienia, łatwiejszą do utrzymania i łatwiejszą do rozszerzenia. W kolejnych odcinkach będziemy opierać się na tej wiedzy i przyjrzeć się bardziej zaawansowanym tematom, takim jak obsługa zdarzeń i ujawnianie ich światu zewnętrznemu, obsługa danych, dostosowywanie naszych komponentów, sposób dystrybucji naszych komponentów do innych programistów, zarówno w naszym zespole, jak i na zewnątrz, i wiele, wiele więcej. Więc przyjdź i dołącz do mnie w tej podróży, aby zostać ekspertem od budowy komponentów SwiftUI. [GRANIE MUZYKI] W tym odcinku dowiemy się, jak wziąć istniejący interfejs użytkownika i zrefaktoryzować go, aby stał się wielokrotnego użytku. Jest to pierwszy krok na drodze do stworzenia komponentu SwiftUI wielokrotnego użytku, który można następnie udostępnić innym programistom. Więc pozwól mi szybko złapać moją maszynę i zacznijmy. Więc tutaj mamy prostą aplikację SwiftUI z widokiem listy jako głównym interfejsem użytkownika. W podglądzie widać, że jest to dość prosty interfejs użytkownika, tylko lista książek z ich okładką i kilkoma szczegółami, takimi jak tytuł i autor.



Jeśli jednak spojrzysz na kod, to już zaczyna on być trochę skomplikowany. A kiedy zaczniemy dodawać nowe funkcje, ten kod szybko zacznie się rozwijać i nie będzie już pasował do jednej strony. Przyjrzyjmy się więc trzem różnym sposobom oczyszczenia tego kodu i uczynienia go bardziej rozszerzalnym. Przede wszystkim wyodrębnijmy kod, który jest odpowiedzialny za rysowanie wierszy listy. Xcode ma wbudowaną obsługę refaktoryzacji, która sprawia, że jest to naprawdę łatwe. Po prostu przytrzymaj klawisz Command, a następnie kliknij widok, który chcesz wyodrębnić, w ten sposób. W menu kontekstowym wybierz Wyodrębnij podwidok i obserwuj, jak Xcode wykonuje swoją magię. Możemy nadać temu nowemu widokowi nazwę, wpisując BookRowView. Teraz zauważysz, że kompilator wydaje błąd mówiący, że książka jest nieznana w tym miejscu. Możemy to naprawić, definiując właściwość na BookRowView, a następnie przekazując bieżący element listy w kolejności dla każdej pętli tutaj. Możemy użyć prostej właściwości zamiast powiązania lub zmiennej stanu, ponieważ widok nadrzędny jest właścicielem stanu. A ponieważ BookRowView nie zawiera żadnych elementów interfejsu użytkownika, które pozwalają użytkownikowi modyfikować książkę, nie ma potrzeby synchronizowania z powrotem z BookRowView do widoku głównego. W przyszłych odcinkach zamierzamy zaimplementować komponent SwiftUI, który pozwala użytkownikowi na dokonywanie modyfikacji, i przyjrzymy się, co to oznacza dla obsługi stanu widoku. Zakończmy przenosząc ten kod do nowego pliku. A ponieważ nasz widok oczekuje parametru, będziemy musieli również zaktualizować dostawcę podglądu i dostarczyć przykładową książkę. Na koniec skonfigurujmy podgląd tak, aby pasował do rozmiaru wiersza, a także dodajmy podgląd dla trybu ciemnego. Tak więc extractSubview jest pierwszym narzędziem do refaktoryzacji widoków SwiftUI. Następna refaktoryzacja, którą chciałbym ci pokazać, jest przydatna, jeśli masz wiele elementów w widoku, które mają te same właściwości wizualne. Na przykład, zarówno nazwisko autora, jak i liczba stron mają ten sam rozmiar czcionki. Aby ułatwić aktualizację ich projektu w przyszłości, wyodrębnijmy te dwa. Teraz jednym ze sposobów, aby to zrobić, byłoby wyodrębnienie ich z podwidoku, tak jak właśnie zrobiliśmy. I to jest świetny pomysł na widoki, które możesz chcieć ponownie wykorzystać w innych widokach. Ale tym razem chciałbym pokazać ci inny sposób, aby to zrobić i zachować kod zawarty w BookRowView. Aby użyć tej refaktoryzacji, kliknij z naciśniętym klawiszem Command nazwę widoku, który chcesz wyodrębnić, a następnie wybierz opcję Wyodrębnij do metody. Ta etykieta tutaj wyświetla szczegóły książki, więc nazwiemy ją etykietą szczegółów. Teraz, niestety, refaktoryzacja nie przeniosła modyfikatora widoku czcionki do metody, więc będę musiał to zrobić ręcznie. Jak widać, funkcja obecnie zwraca tekst z nazwiskiem autora. Aby więc uczynić go wielokrotnego użytku, musimy wprowadzić kilka modyfikacji. Najpierw dodajmy parametr, aby dzwoniący mógł przekazać tekst. Teraz skopiujmy ten tekst tutaj i zastąpmy go nowym parametrem.



Tutaj możemy teraz nazwać naszą nową funkcję Etykieta szczegółów i przekazać tekst, który właśnie skopiowaliśmy. I na koniec, zrefaktoryzujmy etykietę, aby wyświetlić liczbę stron i skorzystajmy z naszej nowej funkcji. Teraz konieczność określenia nazwy parametru tekstowego nie wygląda zbyt ładnie, więc pozbądźmy się etykiety parametru tak po prostu. Korzystając z tej techniki, możemy przypisać znaczenie semantyczne naszym elementom interfejsu użytkownika i uczynić je bardziej wielokrotnego użytku. Na przykład teraz o wiele łatwiej jest zmienić wygląd wszystkich etykiet szczegółów w jednym miejscu. Ostateczna refaktoryzacja wykorzystuje właściwości obliczeniowe i jest najbardziej odpowiednia dla elementów interfejsu użytkownika, które pojawiają się tylko raz. Rzućmy okiem. Pozwól, że zacznę od zdefiniowania nowej obliczonej właściwości o nazwie titleLabel, która zwraca someView. To mówi SwiftUI, że wynikiem tej właściwości będzie someView. Może to być prosty widok, taki jak tekst, ale możemy również użyć bardziej złożonych właściwości, ale możemy również użyć bardziej złożonych struktur widoku. W rzeczywistości, jeśli porównasz podpis tej właściwości z właściwością ciała, zauważysz, że są one dokładnie takie same. Więc używamy tych samych narzędzi, co sam SwiftUI. Następnie wybiorę dwie linie, które są odpowiedzialne za wyświetlanie tytułu książki i przeniosę je do obliczonej właściwości, którą właśnie zdefiniowaliśmy. I wreszcie, mogę po prostu użyć nowej nieruchomości zamiast tych dwóch linii. Mam nadzieję, że podobała Ci się ta pierwsza część naszej podróży do budowania komponentów za pomocą SwiftUI. Dzisiaj nauczyłeś się, jak zrefaktoryzować istniejący widok SwiftUI przy użyciu trzech różnych technik. Wyodrębnianie widoku podrzędnego jest przydatne w przypadku widoków, które możesz chcieć ponownie wykorzystać w innych obszarach aplikacji. Wyodrębnianie widoku do metody jest świetną techniką, gdy chcesz ułatwić zrozumienie złożonego widoku, przypisując znaczenie semantyczne poszczególnym widokom podrzędnym. I wreszcie, wyodrębnienie widoku do obliczonej właściwości jest najbardziej przydatne dla elementów, które pojawiają się tylko raz. Wszystkie te techniki pomogą nam łatwiej budować złożone widoki i ekrany SwiftUI, a my będziemy używać wszystkich trzech w tej serii. W następnym odcinku będziemy opierać się na naszej wiedzy, aby stworzyć pole wprowadzania tekstu wielokrotnego użytku z pływającą etykietą. Teraz, jeśli mi wybaczysz, muszę naprawić ten autobus LEGO, który odegra ważną rolę w następnym odcinku. Dzięki za oglądanie i do zobaczenia w następnym. 





https://youtu.be/Sg0rfYL3utI?si=Qh7QlHEw4ouuSF8c



Hej wszystkim i witamy z powrotem w serii o budowaniu komponentów SwiftUI. W ostatnim odcinku nauczyliśmy się kilku technik ulepszania struktury naszego kodu SwiftUI. A dzisiaj pójdziemy o krok dalej i przyjrzymy się zbudowaniu pola wprowadzania tekstu wielokrotnego użytku z pływającą etykietą. Zanim przejdziemy do kodu, porozmawiajmy najpierw trochę o czymś, co jest kluczowym aspektem SwiftUI. Warto zauważyć, że chociaż Swift jest językiem zorientowanym obiektowo, SwiftUI wykorzystuje tylko w ograniczonym stopniu koncepcję dziedziczenia. Zamiast tego przedkłada kompozycję nad dziedziczenie. A jeśli zbudowałeś dowolny interfejs użytkownika za pomocą SwiftUI, użyłeś już kompozycji do zbudowania swojego interfejsu użytkownika. To trochę jak budowanie LEGO. Na przykład ten autobus jest zbudowany z wielu maleńkich cegiełek, które razem tworzą ten genialny model. Mogę jednak użyć tych samych cegieł, aby zbudować coś zupełnie innego. W rzeczywistości wiele zestawów LEGO zawiera instrukcje budowy dwóch lub nawet więcej różnych modeli z tego samego zestawu klocków. A dzięki ich genialnemu mechanizmowi łączenia ze sobą dwóch lub więcej cegieł poprzez klikanie ich razem, można zbudować prawie wszystko. Kiedy przyjrzymy się bliżej, zobaczymy, że nawet poszczególne części tej magistrali tworzą komponenty. Na przykład, mogę zdjąć ten górny pokład, aby podzielić go na górny i dolny pokład. A w środku mam te wszystkie małe siedzenia. I mogę wziąć to miejsce, na przykład, i włożyć je do tego dolnego pokładu, w ten sposób. Aby wyjaśnić, jak ta zasada działa w SwiftUI, pokażę ci, jak zbudować proste pole wprowadzania tekstu z pływającą etykietą. Zamiast używać dziedziczenia, użyjemy kompozycji do zbudowania tego komponentu, łącząc go z kilku mniejszych podstawowych komponentów SwiftUI. A po drodze wykorzystamy również niektóre z rzeczy, których nauczyliśmy się w poprzednich odcinkach. Aby rozpocząć, stworzyłem bardzo prosty formularz z kilkoma polami wprowadzania tekstu. Rzućmy okiem. Warto zauważyć, że widok pola tekstowego oczekuje tekstu zastępczego. Ten tekst będzie wyświetlany za każdym razem, gdy pole wejściowe jest puste, tak jak ma to miejsce teraz.



Gdy zaczniemy pisać, tekst zastępczy zniknie. Więc teraz użytkownikom trochę trudno jest zobaczyć, co mają wpisać w którym polu, zwłaszcza jeśli wprowadzą błędne informacje lub jeśli zawartość pola nie zapewnia wystarczającego kontekstu, aby zrozumieć, co się dokąd zmierza. Czy nie byłoby o wiele ładniej widzieć tekst zastępczy przez cały czas, na przykład nad polem wprowadzania tekstu? Spróbujmy zbudować prostą wersję dla jednego z naszych pól wejściowych. Dzięki płótnie podglądu SwiftUI bardzo łatwo jest prototypować interfejsy użytkownika na miejscu i od razu zobaczyć, jak wyglądają. Najpierw zawinę to pole tekstowe w VStack, klikając pole tekstowe z wciśniętym klawiszem Command, a następnie wybierając opcję Osadź w VSTack w menu kontekstowym. Następnie pozwól, że dodam widok tekstowy, aby wyświetlić tekst zastępczy. Jednym ze sposobów, aby to zrobić, jest kliknięcie przycisku plus na pasku narzędzi. Spowoduje to wywołanie biblioteki komponentów, w której mogę teraz wyszukiwać tekst. Następnie mogę przeciągnąć element tekstowy z biblioteki i upuścić go w obszarze edytora. Zwróć uwagę, jak edytor kodu tworzy miejsce, aby ułatwić mi wstawianie widoku dokładnie we właściwej pozycji. Teraz upewnijmy się, że wygląda to ładnie, dostosowując wyrównanie elementów w VStack. Najłatwiejszym sposobem na to jest kliknięcie Control-Option-kliknięcie na VSTack, aby wyświetlić inspektora SwiftUI, a następnie wybranie Leading Alignment, w ten sposób. Myślę też, że powinniśmy nieco zmniejszyć etykietę zastępczą. Użyjmy do tego czcionki podpisu. Więc Control-Option-kliknij na widok tekstowy, a następnie wybierz styl Caption Font w inspektorze SwiftUI. I na koniec pozwól mi zmienić kolor tekstu na pierwszym planie, aby użyć koloru akcentu naszej aplikacji. I tym razem użyję edytora kodu, aby wprowadzić zmianę. Jak na razie, tak dobrze. Jednak tekst zastępczy jest teraz widoczny przez cały czas. Zamiast tego chcę, aby był widoczny tylko wtedy, gdy użytkownik wprowadził tekst do pola tekstowego. Jednym ze sposobów, aby to osiągnąć, jest uczynienie widoku tekstu warunkowym. Kliknij z wciśniętym klawiszem Command w widoku tekstowym, a następnie wybierz opcję Utwórz warunkowe z menu kontekstowego. Chcemy pokazać ten widok tylko w przypadku, gdy atrybut imienia nie jest pusty. Więc właściwym warunkiem jest, jeśli nie, adres wysyłki.imię.pusty. Gdy atrybut pierwszej nazwy jest pusty, chcemy ukryć ten widok, abyśmy mogli usunąć całą gałąź else instrukcji warunkowej. Zobaczmy, jak to wygląda. Teraz, jeśli wprowadzę swoje imię, pojawi się etykieta zastępcza. Jednak nie jest to zbyt gładkie.



Dodajmy więc animację, aby to naprawić. Możemy określić animację, której SwiftUI powinien używać dla dowolnego elementu tego VStack, używając modyfikatora .animationView i wybierając domyślną animację. Podgląd na żywo jest nadal aktywny, więc możemy śmiało przyjrzeć się wynikowi. Nieźle, ale myślę, że wyglądałoby to znacznie lepiej, gdyby tekst zastępczy przesuwał się płynnie z wnętrza pola tekstowego do pozycji nad nim. Aby osiągnąć to zachowanie, wykorzystamy VStack SwiftUI. Dzięki temu możemy umieszczać elementy jeden na drugim, podobnie jak stos przezroczystych slajdów. Więc najpierw zawińmy pole tekstowe w ZStack. Tym razem użyję edytora kodu. Następnie pozwól, że dodam widok tekstowy dla tekstu zastępczego. Upewnijmy się, że tekst zastępczy jest wyrównany w lewo. Niestety, nie możemy użyć do tego inspektora SwiftUI. Więc będziemy musieli to zrobić ręcznie. Fajnie. Zauważyłeś? Widok tekstowy dokładnie pasuje do tekstu zastępczego widoku pola tekstowego pod nim. Zaktualizujmy kolor pierwszego planu do .placeholderText. A teraz możemy ustawić tekst zastępczy pola tekstowego na pusty ciąg znaków. Teraz, gdy mamy to na miejscu, możemy zacząć myśleć o animowaniu etykiety zastępczej. Są trzy rzeczy, które chcemy animować. Chcemy nieznacznie przesunąć etykietę zastępczą w górę, gdy tylko użytkownik wprowadzi jakiś tekst. Chcemy również nieznacznie zmniejszyć jego rozmiar czcionki. I na koniec chcemy zabarwić etykietę za pomocą akcentującego koloru. Zacznijmy od przesunięcia etykiety w górę. Aby przesunąć etykietę w górę, możemy dostosować jej przesunięcie Y za każdym razem, gdy tekst, który edytujemy, nie jest pusty. Więc najpierw określmy przesunięcie. A następnie dodaj trójsiękowe wyrażenie, które daje 0, jeśli edytowany tekst jest pusty i minus 25 w przeciwnym razie. Zróbmy to samo dla skalowania etykiety zastępczej. Chcemy, aby był w 100% rozmiaru, gdy nie zostanie wprowadzony żaden tekst i 80% rozmiaru, gdy tylko użytkownik wprowadzi jakiś tekst. Możemy zmienić rozmiar etykiety za pomocą modyfikatora widoku efektu skali. Teraz, jeśli wpiszemy jakiś tekst w tym polu, zauważysz, że nie wyrównuje się dobrze. Naprawmy to, zapewniając kotwicę. Teraz wygląda to o wiele lepiej.



Ponieważ SwiftUI używa ramki ograniczającej widok tekstowy, aby określić przestrzeń, którą nasz widok zajmuje w formularzu, będziemy musieli zapewnić trochę dopełnienia u góry widoku. I na koniec zmieńmy odpowiednio kolor. Będziemy chcieli użyć koloru akcentu za każdym razem, gdy pole tekstowe zawiera jakiś tekst. I jako ostatni akcent, mówimy SwiftUI, aby animował wszelkie zmiany w tym widoku, dodając .animation.default do stosu C. A teraz wygląda to dość słodko. Więc teraz wdrożyliśmy dwa różne sposoby wyświetlania tekstu zastępczego unoszącego się na górze pola tekstowego. W następnej i ostatniej sekcji użyjemy techniki, o której dowiedzieliśmy się ostatnio, i wyodrębnimy ten widok do podwidoku, aby uczynić go wielokrotnego użytku. Najpierw wyodrębnijmy stos C do podwidoku. Aby to zrobić, kliknij stos C z naciśniętym klawiszem Command, a następnie wybierz Wyodrębnij podwidok z menu kontekstowego. Nazwijmy to TextInputField. Teraz, tutaj na dole, jest kilka błędów kompilatora, które są związane z faktem, że próbujemy uzyskać dostęp do atrybutu nazwiska w naszym modelu, który nie jest w zakresie naszego nowego widoku. Możemy to naprawić, wprowadzając nową zmienną o nazwie text. A ponieważ jest to powiązanie z atrybutem, który chcemy edytować, musimy oznaczyć go jako @Binding. Mając to na miejscu, możemy teraz zastąpić wszystkie wystąpienia shippingAddress.lastName tekstem. W miejscu połączenia musimy przekazać atrybut, który chcemy edytować. Więc dodajmy tutaj atrybut nazwiska. Teraz to już wygląda całkiem przyzwoicie, ale potrzebujemy też sposobu na określenie tekstu zastępczego. Jak widać tutaj na dole, nadal używamy wartości zakodowanej na stałe. Dodajmy właściwość o nazwie title do naszego nowego widoku wielokrotnego użytku. I zamień zakodowany na stałe ciąg na nasz atrybut title. A w miejscu połączenia musimy teraz podać wartość dla tego nowego parametru. Jeśli pamiętasz, co powiedziałem we wstępie do tego filmu, chcieliśmy się upewnić, że nasz nowy komponent SwiftUI jest zamiennikiem TextField. Jeśli jednak porównasz podpisy połączeń, zauważysz, że są różne. Nasz nowy komponent SwiftUI jest zamiennikiem TextField. Nasz nowy komponent wymaga, aby dzwoniący dostarczył etykietę tytułową. Aby się tego pozbyć, musimy wprowadzić inicjalizator do naszego nowego widoku. Aby usunąć wymóg określenia etykiety tytułu, wystarczy dodać podkreślenie do podpisu. A wiązanie musi być przekazane jako wiązanie sznurka. A potem jesteśmy gotowi przypisać te parametry do ich odpowiednich właściwości. Zauważ, że nie możemy przypisać powiązania bezpośrednio do prognozowanej wartości właściwości tekstowej. Zamiast tego musimy przypisać go do jego wartości opakowanej. A dzięki temu możemy usunąć etykietę tytułową i wywołanie naszego nowego komponentu, co czyni go zamiennikiem TextField. Oznacza to, że możemy zastąpić wszystkie inne wywołania TextField TextInputField. A tu jest zręczna mała sztuczka. Xcode obsługuje edycję wielu kursorów. Po prostu naciśnij Shift-Control, a następnie kliknij wszystkie lokalizacje, które chcesz edytować w tym samym czasie, w ten sposób. A teraz, gdy wpiszę dane wejściowe, zostanie to zmienione wszędzie, gdzie umieściłem kursor. Aby pozostawić edycję z wieloma kursorami, po prostu naciśnij Escape. Wznowijmy podgląd, a następnie zobaczmy, jak daleko zaszliśmy.



Teraz wszystkie pola wejściowe mogą wykorzystać to nowe zachowanie. A dzięki mocy i elastyczności SwiftUI wszystko jest ładnie zamknięte i łatwe w użyciu. Dzisiaj dowiedziałeś się, że SwiftUI przedkłada kompozycję nad dziedziczenie. Zamiast tworzyć podklasy istniejących elementów interfejsu użytkownika i konieczności nadpisywania ich zachowania, możemy użyć kilku mniejszych komponentów interfejsu użytkownika i złożyć je w coś większego. Nauczyłeś się również, jak obsługiwać dane, które są własnością innego widoku. Jest to tak ważny aspekt, że w niektórych nadchodzących odcinkach poświęcimy mu więcej czasu. Spędziliśmy również trochę czasu na uczynieniu naszego komponentu interfejsu użytkownika zamiennikiem wielokrotnego użytku dla wbudowanego widoku SwiftUI. To jest naprawdę potężne, ponieważ ułatwia ludziom przyjęcie twojego komponentu. Idealnie byłoby, gdyby musieli po prostu wyszukać i zastąpić wbudowany komponent niestandardowym komponentem. Podążanie za projektami API Apple jest prawdopodobnie dobrym pomysłem. W końcu spędzili dużo czasu na swoich projektach API. I to, co działa dla nich, powinno działać również dla nas. Więc osiągnęliśmy dzisiaj całkiem sporo, ale jeszcze nie skończyliśmy. W następnych odcinkach przyjrzymy się dystrybucji tego komponentu za pośrednictwem Swift Package Manager i CocoaPods, dodaniu go do biblioteki komponentów Xcode, dodaniu walidacji danych wejściowych, obsłudze bezpiecznego wprowadzania, uczynieniu komponentu bardziej konfigurowalnym i nie tylko. Więc bądź na bieżąco i nie zapomnij zasubskrybować kanału. Dzięki za oglądanie i do zobaczenia w następnym. 



https://youtu.be/KKxCWs-BorE?si=REOEBMP8DUc7Y6Yt



Ostatnim razem stworzyliśmy pole wprowadzania tekstu z pływającą etykietą. A dzisiaj chcę ci pokazać, jak możemy dodać kilka właściwości do widoku, abyśmy mogli go skonfigurować podczas korzystania z niego w naszym interfejsie użytkownika. Aby to osiągnąć, użyjemy modyfikatorów widoku, rozszerzeń i środowiska. Korzystając ze środowiska, dodamy kilka naprawdę fajnych supermocy do naszego komponentu Swift UI. I absolutnie nie chcesz tego przegapić. [GRANIE MUZYKI] Zanim jednak przejdziemy do kodu, przyjrzyjmy się, co dzisiaj zbudujemy. Więc tutaj, w naszym formularzu wejściowym, mamy kilka pól wprowadzania tekstu. I chciałbym być w stanie wyświetlić przycisk Wyczyść w niektórych z tych pól, tak jak ten, który znasz z aplikacji Apple, takich jak aplikacja Mail lub ekran główny. Więc kiedy wprowadzam jakiś tekst w tych polach tekstowych, mogę użyć przycisku Wyczyść, aby usunąć to, co wpisałem. I zauważysz, że nie wszystkie pola wejściowe pokazują przycisk Wyczyść. Może to być spowodowane tym, że może to nie mieć sensu dla wszystkich tych pól lub dlatego, że mogę używać tych pól wejściowych na ekranie, na którym nie chcę dawać użytkownikom opcji wyczyszczenia danych wejściowych. Więc może być kilka powodów, dla których chcemy pokazać przycisk Wyczyść. I czasami nie chcemy tego pokazywać. Fajnie. Wróćmy więc do miejsca, w którym spuściliśmy ostatni raz i zacznijmy to wdrażać. Więc oto kod, który napisaliśmy ostatnim razem. Oto formularz, który widzisz po prawej stronie w podglądzie. A na dole znajduje się kod pola wprowadzania tekstu.



Ponieważ celem tego programu jest nauczenie Cię, jak stworzyć widok SwiftUI wielokrotnego użytku, powinniśmy wyodrębnić ten kod do osobnego pliku, abyśmy mogli go ponownie wykorzystać w innych projektach. Przenieśmy to do nowego pliku. Więc niestety, Xcode nie ma wyodrębnienia do refaktoryzacji plików. Więc będziemy musieli to zrobić ręcznie. Więc zamierzam wyciąć kod i utworzyć nowy plik o nazwie podobnej do pola wprowadzania tekstu widoku. I wygodnie, wszystko w tym pliku ma właściwą nazwę. Więc możemy po prostu zastąpić domyślny widok kodem, który właśnie skopiowaliśmy. Naprawmy ten błąd kompilatora tutaj i udostępnijmy etykietę dla pola wprowadzania tekstu i stałe powiązanie. Po prostu użyję mojego imienia. Użyjmy również rozmiaru, który pasuje, abyśmy mogli lepiej zobaczyć, jak wygląda ten widok. OK, więc najpierw dodajmy przycisk Wyczyść. Chcemy, aby przycisk Wyczyść unosił się nad resztą widoku. Więc najpierw stwórzmy nakładkę. A teraz możemy stworzyć przycisk wewnątrz nakładki. Gdy użytkownik dotknie przycisku, chcemy wyczyścić tekst. Powiedzmy więc, że tekst równa się pustemu ciągowi. I zamiast tekstu chcemy wyświetlić obraz. Możemy użyć ikony Mnożenia z symboli sf. Więc użyjmy nazwy systemu obrazu multiply.circle.fill. OK, ale zamiast używać koloru akcentującego, użyjmy szarości systemowej. Używając szarości systemowej, upewniamy się, że działa to również w trybie ciemnym. Tutaj, pozwól mi dodać podgląd trybu ciemnego. OK, świetnie. Ale układ nie wygląda dobrze. Wyrównajmy przycisk. Najłatwiej to zrobić, owinąć to w HStack i włożyć przekładkę. I bum, przycisk Clear jest wyrównany w prawo. Fajnie, więc zanim przejdziemy dalej, sprawdźmy, czy to działa dobrze z długimi tekstami. 



Tak, więc niestety, to trochę się nakłada. Ale możemy to naprawić, dodając trochę dopełnienia do pola tekstowego. Więc teraz powiedzieliśmy w polu tekstowym, że jest trochę mniej miejsca. Więc zacznie używać wielokropka na końcu tego długiego sznurka. Świetnie, to wygląda o wiele lepiej. Mimo że niewiele zrobiliśmy, kod zaczyna wyglądać na nieco zatłoczony. Spróbujmy ułatwić czytanie kodu poprzez refaktoryzowanie tego przycisku Wyczyść. Zamiast używać refaktoryzacji podwidoku wyodrębnienia, wyodrębnię to do obliczonej właściwości. To pomaga mi lepiej uporządkować mój kod. I nadal mogę uzyskać dostęp do wszystkich właściwości w moim głównym widoku. Wyjaśniłem to bardziej szczegółowo w pierwszym filmie z tego programu. Więc jeśli chcesz dowiedzieć się więcej o tym, kiedy użyć jakiej refaktoryzacji, idź i sprawdź to. OK, pozwól mi najpierw stworzyć obliczoną właściwość. A następnie przesuń kod dla przycisku Wyczyść w górę za pomocą polecenia, opcji i nawiasu kwadratowego. A potem wewnątrz nakładki, mogę teraz zadzwonić do ClearButton, aby wyrenderować przycisk Wyczyść. A kiedy jesteśmy przy tym, pozwól mi również wyczyścić przycisk i użyć składni obudowy ścieżki Swift. Otwórz menu Actions kodu za pomocą Command, Shift, A, a następnie wybierz Convert to Trail Enclosure. Patrząc na zapowiedź, widzimy, że nasza refaktoryzacja zakończyła się sukcesem. Nadal pokazuje ten sam widok. Świetnie. Więc cofnijmy się na chwilę i zastanówmy się, jak moglibyśmy włączyć lub wyłączyć przycisk Wyczyść. Więc jednym ze sposobów, aby to zrobić, może być po prostu dodanie kolejnego parametru do konstruktora i pozwolić dzwoniącemu zdecydować, czy pokazać przycisk Wyczyść, czy nie. To by technicznie zadziałało, ale ma poważną wadę. Jeśli dodamy coraz więcej sposobów dostosowywania naszego widoku, lista parametrów inicjalizatora będzie coraz dłuższa, co utrudni czytanie i zrozumienie, której wersji przeciążonej użyć. A jeśli spojrzysz na wszystkie inne widoki SwiftUI, nie jest to sposób, w jaki Apple zbudował własne widoki. Wydaje się, że ich podejście polega na przekazywaniu tylko podstawowych parametrów za pomocą inicjalizatora i używaniu modyfikatorów widoku do konfigurowania widoku. I to też zamierzamy zrobić. Będąc w Rzymie, rób tak, jak Rzymianie. Więc naszkicujmy, jak to może wyglądać. SwiftUI ma modyfikator widoku o nazwie Hidden, którego możemy użyć, aby całkowicie ukryć widok. Pozwól, że pokażę ci, jak to działa w podglądzie dostawcy. Bum. Widok całkowicie znika. OK, fajnie.



Więc co powiesz na to, żebyśmy po prostu nazwali nasz modyfikator widoku ClearButtonHidden, w ten sposób. I dodajmy parametr, aby faktycznie powiedzieć, czy chcemy, aby był widoczny, czy niewidoczny. Teraz, oczywiście, kompilator będzie narzekał, ponieważ to jeszcze nie istnieje. Ale myślę, że to wygląda na dobre API. Chodźmy dalej i zaimplementujmy to. Stwórzmy rozszerzenie, które zawiera kod do kierowania naszą własnością. Uczynię to rozszerzeniem na TextInputView. Jedną z fajnych cech SwiftUI jest to, że używa płynnego interfejsu API. To właśnie umożliwia modyfikatory widoku łańcuchowego. Kluczem do implementacji płynnych interfejsów API jest zwrócenie odniesienia do instancji, na której działasz. Zdefiniujmy więc funkcję o nazwie ClearButtonHidden, która pasuje do nazwy, którą naszkicowaliśmy w podglądzie. I użyjmy nienazwanego parametru, abyśmy mogli bezpośrednio przekazać prawdę lub fałsz bez konieczności określania nazwy parametru. Aby upewnić się, że możemy użyć tego jako płynnego interfejsu API, musimy zwrócić nieprzezroczysty widok i zwrócić odniesienie do siebie. OK, jak właściwie przełączamy widoczność ClearButton? Nie możemy modyfikować stanu widoku, ponieważ jesteśmy poza ciałem. Co by było, gdybym ci powiedział, że najłatwiejszym i najbardziej elastycznym sposobem na to jest wykorzystanie środowiska? W ten sposób jest to realizowane w samym SwiftUI. I ma to szereg zalet, które omówimy za chwilę. Więc na wysokim poziomie, chcemy zrobić dwie rzeczy. Po pierwsze, chcemy zapisać wartość w środowisku widoku, która mówi nam, czy ClearButton powinien być widoczny, czy nie. I po drugie, musimy słuchać tej wartości środowiska w naszym widoku, abyśmy mogli aktualizować widok za każdym razem, gdy zmienia się wartość. Do odczytu wartości ze środowiska możemy użyć wrappera właściwości @Environment.



A jeśli zrobiłeś jakąkolwiek ilość rozwoju SwiftUI, będziesz używał tego wcześniej. Ale jak możemy zdefiniować niestandardowy klucz środowiska? Przyjrzyjmy się dokumentacji Apple. Tutaj widzimy, że musimy zrobić dwie rzeczy. Po pierwsze, musimy zdefiniować strukturę, która jest zgodna z kluczem środowiska i zawiera domyślną wartość dla naszej nowej wartości środowiska. I po drugie, musimy rozszerzyć strukturę wartości środowiska o nową właściwość. OK, zróbmy to. Pozwól, że najpierw utworzę strukturę dla wartości domyślnej. Nazwę to textInputFieldClearButtonHidden. I możesz wybrać dowolną nazwę, ale musi ona być zgodna z kluczem środowiskowym. A teraz łatwo jest użyć uzupełnienia kodu, aby uzyskać tę domyślną wartość. Definiując domyślną wartość jako false, upewniamy się, że przycisk clear nie jest domyślnie ukryty. I z tym na miejscu, pozwól mi szybko stworzyć rozszerzenie dla wartości środowiska. Tutaj używamy typu klucza środowiska jako indeksu indeksu dolnego do odczytu i aktualizacji wartości w środowisku. Doskonały. Więc teraz możemy użyć tego do przechowywania czystego stanu przycisku w środowisku. Możemy użyć modyfikatora widoku środowiska, aby ustawić wartość z wnętrza naszego własnego modyfikatora widoku. Więc kompilator narzeka, ponieważ nie używamy wyniku wywołania do środowiska. A to dlatego, że środowisko jest modyfikatorem widoku. Wszystkie modyfikatory widoku zwracają widok, na którym działają, lub zmodyfikowaną wersję widoku, aby być precyzyjnym. A to oznacza, że nie musimy zwracać instancji jaźni, ale zamiast tego możemy użyć wyniku wezwania do środowiska. Usuńmy więc całą tę linię. A teraz, dzięki niejawnym zwrotom, wynik wywołania do środowiska zostanie zwrócony. Od razu. Teraz, jako ostatni krok, przeczytajmy tę wartość w naszym ujęciu. Zdefiniujmy właściwość o nazwie clearButtonHidden, a następnie użyj modyfikatora addEnvironmentView, aby odczytać wartość ze środowiska. A teraz ukryjmy przycisk clear zgodnie z tym stanem, zawijając zawartość HStack w warunkowy. Zobaczmy, jak to wygląda. Więc to nie wygląda tak źle, ale jest mały problem z bardzo długim tekstem tutaj. A to dlatego, że nie usunęliśmy wyściółki. Więc zróbmy to szybko.



Najlepszym sposobem na to jest po prostu użycie obliczonej właściwości, która mówi nam, ile dopełnienia potrzebujemy. Jeśli wyraźny przycisk jest widoczny, potrzebujemy dopełnienia 25 pikseli. A jeśli jest ukryty, nie potrzebujemy wyściółki. Więc możemy zastąpić zakodowaną wartość tutaj właściwością obliczeniową. A kiedy podgląd się zaktualizuje, zobaczymy, że teraz wygląda to znacznie lepiej. Właściwie użyjmy podglądu, aby zobaczyć to w akcji. Mogę więc włączać i wyłączać przycisk clear za pomocą tego modyfikatora widoku, co jest naprawdę fajne. I mogę nawet użyć parametru, aby zwiększyć widoczność przycisku. To jest świetne, ale czy nie byłoby wspaniale, gdybyśmy mogli wyłączyć to dla wszystkich elementów pojemnika naraz? Pozwól, że pokażę ci, co mam na myśli. Wróćmy więc do formy. I tutaj, w formie, mamy wszystkie nasze pola. Teraz pozwól mi użyć modyfikatora widoku wielkich liter tekstowych w ostatnim polu wejściowym, aby zmienić wszystko w tym polu na wielkie litery. Fajnie. A teraz przesunę tę linię w dół, aby dotyczyła całej sekcji. Bum. Teraz wszystkie pola są wielkimi literami. Więc czy możemy zrobić to samo dla przycisku Clear? Zobaczmy. Najpierw zastosuję modyfikator widoku do jednego z pól wejściowych, aby ukryć przycisk wyczyszczenia tylko dla tego jednego pola wejściowego. A teraz zobaczmy, czy mogę zastosować to do sekcji. Wygląda więc na to, że nie możemy. Sprawdźmy komunikat o błędzie. OK.

Więc komunikat o błędzie mówi, że sekcja nie ma ukrytej notatki o nazwie czysty przycisk. I to jest prawda. Definiujemy to tylko w widoku wprowadzania tekstu. I nie możemy zbyt dobrze stworzyć rozszerzenia dla każdego rodzaju widoku SwiftUI tylko po to, aby zarejestrować nasz modyfikator widoku. I właściwie nie musimy. Wróćmy do naszego poglądu. Wróćmy do naszego poglądu. A potem uczyń to rozszerzeniem na widok. Racja. Wróćmy do formy, aby sprawdzić, czy to teraz działa. Po aktualizacji podglądu widzimy, że modyfikator widoku jest teraz zastosowany do całej sekcji i wszystkich widoków w środku. Więc jeśli kiedykolwiek zastanawiałeś się, dlaczego modyfikatory widoku są przedłużeniem widoku zamiast konkretnego widoku, na którym chcesz je zastosować, teraz wiesz. I to nawet działa, jeśli chcę ponownie włączyć przycisk przezroczystości tylko dla jednego pola. Sprawdź to. Bum. Przycisk Wyczyść jest wyłączony dla wszystkich pól z wyjątkiem tego. A wszystko to działa, ponieważ SwiftUI zarządza dla nas środowiskiem. Całkiem fajnie, co? Gratuluję dotrowania do końca. Jeśli zakodowałeś i chciałbyś porównać swój wynik z oficjalnym rozwiązaniem, sprawdź repozytorium tej serii, w którym opublikuję cały kod, który widzisz w tych filmach. Zrozumienie, jak korzystać ze środowiska, jest ważnym krokiem w pisaniu konfigurowalnych widoków SwiftUI, które można ponownie wykorzystać w różnych projektach, a nawet udostępnić społeczności. W następnym odcinku przyjrzymy się, jak w bezpieczny sposób odsłonić wewnętrzny stan komponentu światu zewnętrznemu. Może się to przydać, na przykład, jeśli chcesz zbudować złożoną walidację formularza i potrzebujesz dostępu do stanu walidacji swoich niestandardowych pól wejściowych. Mam nadzieję, że podobał ci się ten odcinek. A jeśli to zrobiłeś, daj mi kciuk w górę. A także, nie zapomnij zasubskrybować kanału i uderzyć w ikonę dzwonka. Dzięki za oglądanie. I do zobaczenia w następnym.





https://youtu.be/eYrirXFLuZ8?si=LRarBi08Bir0RXZG



 Ostatnim razem dodaliśmy przycisk Wyczyść do naszego pola wprowadzania tekstu wielokrotnego użytku. A dzisiaj pokażę ci, jak ujawnić przegląd międzystanowy. Dzięki temu użytkownicy twojego komponentu mogą reagować na zmiany, które zachodzą w twoim komponencie. Na przykład, aby wyświetlić niestandardowe komunikaty o błędach, jeśli użytkownik wprowadził nieprawidłowe dane. Zacznijmy. [GRANIE MUZYKI] W porządku. Dzisiaj przyjrzymy się, w jaki sposób nasze pole wprowadzania tekstu może sygnalizować światu zewnętrznemu, że użytkownik wprowadził nieprawidłowe dane. Aby lepiej zrozumieć, jak by to wyglądało, spójrzmy na przykładową aplikację. Więc tutaj mamy prosty formularz wejściowy, który prosi użytkownika o podanie swojego adresu e-mail, a następnie potwierdzenie go. To dość standardowe i prawdopodobnie widziałeś już takie formy. Dlatego chcemy mieć pewność, że użytkownik wprowadzi prawidłowy adres e-mail w obu polach. Musimy również upewnić się, że oba adresy e-mail są zgodne.



To jest cały sens proszenia ludzi o dwukrotne wprowadzenie adresu e-mail, prawda? Tak więc przycisk Prześlij powinien być włączony tylko wtedy, gdy oba te warunki są prawdziwe. Tak więc obecnie oba pola wejściowe wyświetlają komunikat o błędzie, wprowadź prawidłowy adres e-mail, ponieważ są puste. OK. Więc pozwól mi wpisać adres e-mail. Użyjmy test@test.com. I jak tylko napiszę, interfejs użytkownika aktualizuje się i mówi mi, że to nie jest prawidłowy adres e-mail. Więc pozwól mi wpisać pełny adres. I jak tylko jest to prawidłowy adres e-mail, komunikat o błędzie znika, a zamiast tego pojawia się nazwa pola. Ale zamiast tego na górze formularza wejściowego znajduje się kolejny komunikat o błędzie, który mówi, że e-maile nie pasują, co jest oczywiście prawdą. OK, fajnie. Więc pozwól mi potwierdzić mój adres e-mail. I jak tylko wpisuję ostatnią literę, wszystkie warunki są spełnione i przycisk staje się aktywny. Słodki. Aby to wdrożyć, musimy zrobić kilka rzeczy. Najpierw musimy dodać właściwość do pola wprowadzania tekstu, która pozwala nam określić, że określone pole wprowadzania jest obowiązkowe. Następnie możemy dodać trochę kodu, aby zweryfikować dane wejściowe użytkownika. Jeśli wejście jest nieprawidłowe, wyświetlimy to na małej etykiecie błędu tuż nad polem wejściowym. Więc potrzebujemy do tego trochę dodatkowego interfejsu użytkownika. I-- i to jest kluczowy moment dla tego odcinka-- zamierzamy ujawnić stan walidacji światu zewnętrznemu. Więc kiedy to wszystko zostanie wdrożone, pokażę ci, jak zaktualizować formularz wejściowy w naszej przykładowej aplikacji i użyć Combine do obsługi ogólnego stanu walidacji formularza.



Więc mamy dużo do zrobienia. Wskoczmy od razu. Tak więc jako pierwszy krok, chcemy zaimplementować właściwość, aby powiedzieć polu wprowadzania tekstu, że jest to obowiązkowe. Teraz twoim pierwszym instynktem może być dodanie nowego parametru do inicjatora pola wprowadzania tekstu. Ale zaowocowałoby to dość brzydkim API, zwłaszcza gdybyśmy później dodali więcej parametrów. Lepszym sposobem na to jest użycie modyfikatora widoku. I oczywiście zastosujemy to, czego nauczyliśmy się w poprzednim odcinku i wykorzystamy środowisko do wdrożenia tego modyfikatora widoku. Zacznijmy. Zanim więc będziemy mogli wdrożyć rozszerzenie na widok, aby ułatwić użytkownikowi naszego komponentu uczynienie go obowiązkowym, musimy przygotować infrastrukturę do zapisu w środowisku. Zrobiliśmy to już wcześniej dla przycisku Wyczyść, jak widać z kodu tutaj. Więc to powinno być teraz łatwe. OK, więc najpierw zdefiniujmy klucz środowiskowy. Aby to zrobić, definiujemy pole wprowadzania tekstu obowiązkowe i dostosowujemy je do klucza środowiska. Domyślnie chcemy, aby wszystkie nasze pola były nieobowiązkowe. Więc zdefiniujemy domyślną wartość wartości środowiska jako false. Fajnie, więc teraz, gdy mamy klucz, musimy stworzyć rozszerzenie dotyczące wartości środowiska. To pozwoli nam zapisać naszą wartość w środowisku. Jest obowiązkowy, zasadniczo jest własnością obliczeniową. I używamy klucza środowiskowego, który właśnie stworzyliśmy, do czytania i pisania z i do środowiska. Teraz, gdy jest to na miejscu, możemy utworzyć rozszerzenie na widoku, aby nasze pole wprowadzania tekstu było obowiązkowe. To rozszerzenie można zastosować do dowolnego widoku. A jeśli zastanawiasz się, dlaczego tak jest, sprawdź w poprzednim odcinku, w którym wyjaśniam, że jest to naprawdę niezbędne. 



A jeśli dzwoniący nie poda wartości, założymy prawdę, która jest znaczącą wartością domyślną. W końcu, kiedy zastosujesz ten modyfikator widoku do pola wprowadzania tekstu, oczekujesz, że pole wejściowe stanie się polem obowiązkowym, prawda? Wewnątrz funkcji używamy klucza środowiska, który właśnie stworzyliśmy, aby zapisać wartość w środowisku. Ta infrastruktura pozwala nam używać środowiska SwiftUI do określania zachowania naszych komponentów UI. To jest dokładnie to, co robi wiele komponentów SwiftUI. I to jest powód, dla którego możesz użyć modyfikatora widoku na komponencie kontenera, takim jak HStack, i zastosować go do wszystkich komponentów interfejsu użytkownika, które znajdują się w tym kontenerze. Jeśli chcesz dowiedzieć się więcej na ten temat, polecam obejrzeć poprzedni odcinek tutaj, gdzie wyjaśnię to bardziej szczegółowo. Doskonały. Więc śmiało użyjmy tego w naszym komponencie teraz. OK, więc wiesz, że możemy użyć opakowania właściwości addEnvironment do odczytania informacji ze środowiska. I to właśnie zamierzamy teraz zrobić. Więc tutaj, zdefiniujmy właściwość o nazwie isMandatory i pobierzmy jej wartość ze środowiska. Niesamowite. Oznacza to, że możemy teraz sprawdzić stan tej właściwości, gdy musimy zdecydować, czy zweryfikować, czy użytkownik wprowadził jakikolwiek tekst. Więc następnym krokiem jest wdrożenie naszej logiki walidacji. Za każdym razem, gdy użytkownik coś wpisuje, chcemy sprawdzić, czy wpisał poprawną rzecz i chcemy zweryfikować jego dane wejściowe. Są na to dwa sposoby. Możemy albo użyć combine i skonfigurować potok na właściwości text na naszym komponencie, albo możemy użyć modyfikatora onChangeOfView. Tym razem użyjmy modyfikatora onChangeOfView, aby zobaczyć, jak to działa. Możemy zastosować modyfikator onChangeOfView do dowolnego widoku, a następnie określić właściwość, którą chcemy obserwować. OK, więc aby śledzić stan walidacji, potrzebujemy dwóch dodatkowych zmiennych. Jeden do śledzenia, czy to pole wejściowe jest prawidłowe, a drugi do przechowywania komunikatu o błędzie, który możemy wyświetlić użytkownikowi.



Zdefiniujmy więc dwie właściwości addState na górze pliku. A teraz możemy ich użyć do śledzenia statusu walidacji tutaj w obsłudze onChangeOf. Świetnie. Dodajmy teraz widok tekstowy, aby wyświetlić komunikat o błędzie za każdym razem, gdy wejście tekstowe jest nieprawidłowe. Ponieważ używamy ZStack do zarządzania układem wszystkich naszych widoków, oznacza to, że możemy po prostu dodać ten nowy tekst do wszystkich innych widoków, a zostanie on wyświetlony w widoku. Dodajmy więc nowy tekst. I widzimy, że mamy nowy tekst. I widzimy, że mamy nowy tekst. I widzimy, że mamy nowy tekst na wierzchu wszystkich innych widoków i będzie on wyświetlany we właściwej przestrzeni. A formatowanie jest bardzo podobne do pola tekstowego poniżej, więc możemy po prostu użyć tych samych wartości. Fajnie. Więc zobaczmy teraz, czy to działa i uruchommy to w podglądzie. Ale zanim będziemy mogli to zrobić, musimy włączyć walidację dla pól wejściowych. Przejdźmy więc do formularza sprawdzania poprawności wiadomości e-mail i dodajmy modyfikator isMandatoryView do pól wejściowych. W porządku. A teraz odświeżmy podgląd i wypróbujmy to. Racja. Więc jeśli coś wprowadzę, ogólny komunikat o błędzie powie mi, że e-maile muszą się zgadzać. Ale co z pustym stanem? Czy nie powinienem zobaczyć komunikatu o błędzie dla pustych pól wejściowych? I wygląda na to, że to działa, ale dopiero po tym, jak coś napiszę, a potem ponownie to usunę. Cóż, okazuje się, że onChange jest uruchamiany tylko wtedy, gdy obserwowana wartość jest faktycznie zmieniona. A kiedy widok początkowo się pojawi, żadna zmiana nie zostanie wywołana. Ale możemy użyć modyfikatora onAppearView, aby uruchomić logikę walidacji, gdy tylko pojawi się widok. I zamiast powielać ten kod, najpierw przetłumaczę go na nową funkcję. Wybierz więc ten fragment kodu, otwórz menu kontekstowe, a następnie wybierz wyodrębnij do metody. Fajne jest to, że mogę zacząć wpisywać nazwę nowej funkcji, sprawdzić poprawność i zostanie ona zaktualizowana zarówno tutaj, jak i na stronie połączenia. Mogę teraz dodać modyfikator onAppearView i wywołać naszą nową funkcję od wewnątrz. A teraz szybko sprawdźmy to jeszcze raz, odświeżając podgląd. A teraz widzimy, że oba pola pokazują komunikat walidacyjny, ponieważ są puste.



A kiedy wprowadzę kilka tekstów, komunikaty o błędach znikną. Racja, więc wydaje się, że to działa dobrze, ale być może zauważyłeś, że przycisk Prześlij jest aktywny, nawet jeśli adresy e-mail są nieprawidłowe. A to dlatego, że nie ujawniliśmy jeszcze stanu isValid światu zewnętrznemu. Aby to zrobić, musimy zamiast tego użyć wiązania. Wiązania pozwalają widokom na dzielenie się stanem. Jeden widok zwykle definiuje zmienną atState lub opublikowaną właściwość na obserwowalnym obiekcie, a drugi widok akceptuje odniesienie do tego jako powiązanie. Oba widoki mogą następnie zmienić wartość w zmiennej, a drugi widok otrzyma aktualizację. W naszym przypadku pole wprowadzania tekstu może zmienić powiązanie isValid, co zostanie odzwierciedlone w formularzu zawierającym pole wejściowe. Więc to jest dokładnie to, czego potrzebujemy. Przejdźmy dalej i dodajmy powiązanie, którego możemy użyć do przekazania stanu walidacji światu zewnętrznemu. Po pierwsze, zamierzam dodać nową prywatną zmienną @Binding do góry naszego komponentu. Następnie dodam opcjonalny parametr do inicjalizatora, aby wywołujący mógł przekazać powiązanie. A potem tutaj, w inicjalizatorze, przypiszę to powiązanie do prywatnego @Binding, które właśnie stworzyłem. W przypadku, gdy dzwoniący nie zapewnia powiązania, zapewnimy stałe powiązanie z prawdziwym sobą. Świetnie. To pomaga nam komunikować się ze światem zewnętrznym, ale jeszcze nie skończyliśmy. Jeśli zwróciłeś szczególną uwagę, zauważysz, że mamy teraz dwie zmienne do śledzenia stanu walidacji - isValid i isValidBinding. isValid to nasza wewnętrzna reprezentacja, a isValidBinding to połączenie ze światem zewnętrznym. Aby upewnić się, że wewnętrzny stan walidacji naszego komponentu zostanie propagowany do świata zewnętrznego, musimy dodać słuchacza właściwości do isValid. W ten sposób wszelkie zmiany w isValid zostaną zastosowane do isValidBinding, które w konsekwencji będą widoczne na zewnątrz. W porządku. A wraz z tym nadszedł czas, aby zaktualizować kod, który używa tego pola wprowadzania tekstu. Wróćmy do modelu widoku sprawdzania poprawności wiadomości e-mail. Teraz, w modelu widoku, mamy już dwie opublikowane właściwości, których możemy użyć do śledzenia stanu walidacji pól wejściowych. Pozwólcie więc, że szybko je odkomentuję. A potem tutaj, mamy połączony potok, który obecnie korzysta z wydawcy dopasowań wiadomości e-mail i przypisuje jego wyniki do właściwości isFormValid. Połączmy więc tego wydawcę z wydawcami, którzy śledzą stan walidacji naszych pól wejściowych. Fajnie.



Więc isFormValid jest używany do przełączania przycisku Prześlij tutaj. I wszystko, co pozostaje do zrobienia, to połączyć opublikowane właściwości z isValidBinding w naszym polu wprowadzania tekstu za pomocą zaktualizowanego inicjatora. W porządku. Odświeżmy teraz podgląd, aby zobaczyć to w akcji i sprawdzić, czy wszystko działa zgodnie z oczekiwaniami. OK. Więc pola są oznaczone jako nieważne, ponieważ są puste. Więc to dobrze. To lepiej niż wcześniej. A kiedy zacznę pisać w pierwszym polu, stanie się ono ważne. Ale formularz jest nadal nieprawidłowy, ponieważ pola się nie zgadzają. Więc pozwól mi to naprawić. W porządku. I jak tylko oba pola pasują do siebie, przycisk Prześlij staje się aktywny. Teraz, jeśli przypomnisz sobie aplikację, którą pokazałem ci na początku tego odcinka, zauważysz, że nasza implementacja nie jest jeszcze do końca kompletna. Możemy określić, że pole wejściowe jest obowiązkowe. A jeśli użytkownik nie wprowadził żadnego tekstu, nasza implementacja poprawnie to wykryje i ustawi właściwość isValid na false. A ponieważ jest to powiązanie, możemy reagować na wszelkie zmiany tej właściwości i odpowiednio zaktualizować otaczający interfejs użytkownika, na przykład, włączając i wyłączając przycisk Prześlij. Nie możemy jednak wykryć, czy użytkownik faktycznie wprowadza prawidłowy adres e-mail. I to jest coś, co zamierzamy wdrożyć następnym razem. Jeśli podobał Ci się ten odcinek, naciśnij przycisk Thumbs Up, aby dać mi znać. I nie zapomnij zasubskrybować kanału, aby jako pierwszy dowiedzieć się, kiedy przesyłam nowe materiały. A jeśli nie, sprawdź również inne filmy z tej serii. Zapraszam do pozostawienia jakichkolwiek pytań w sekcji komentarzy poniżej, a ja dołożę wszelkich starań, aby na nie odpowiedzieć. Dzięki za oglądanie i do zobaczenia w następnym.
